name: üöÄ Automated Production Release

on:
  workflow_run:
    workflows: ["QA Pipeline"]
    types: 
      - completed
    branches:
      - main
      - release/*
  
  # Manual trigger for emergency releases
  workflow_dispatch:
    inputs:
      force_release:
        description: 'Force release (bypass some checks)'
        required: false
        default: 'false'
        type: boolean
      release_type:
        description: 'Release type'
        required: true
        default: 'patch'
        type: choice
        options:
          - patch
          - minor
          - major
          - hotfix

env:
  RELEASE_BRANCH: main
  MIN_READINESS_SCORE: 95
  REQUIRED_APPROVAL: "APPROVED FOR RELEASE"

jobs:
  validate-release-readiness:
    name: üîç Validate Release Readiness
    runs-on: ubuntu-latest
    if: github.event.workflow_run.conclusion == 'success' || github.event_name == 'workflow_dispatch'
    
    outputs:
      should_release: ${{ steps.readiness_check.outputs.should_release }}
      readiness_score: ${{ steps.readiness_check.outputs.readiness_score }}
      release_decision: ${{ steps.readiness_check.outputs.release_decision }}
      release_tag: ${{ steps.generate_tag.outputs.release_tag }}
    
    steps:
      - name: üì• Checkout Repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          token: ${{ secrets.GITHUB_TOKEN }}
      
      - name: üîç Check Release Readiness
        id: readiness_check
        run: |
          echo "Checking for release readiness artifacts..."
          
          # Find latest readiness summary
          READINESS_FILE=""
          for file in RELEASE_READINESS_SUMMARY.md *readiness_summary*.md *readiness_summary*.json; do
            if [[ -f "$file" ]]; then
              READINESS_FILE="$file"
              break
            fi
          done
          
          if [[ -z "$READINESS_FILE" ]]; then
            echo "‚ùå No readiness summary found"
            echo "should_release=false" >> $GITHUB_OUTPUT
            echo "readiness_score=0" >> $GITHUB_OUTPUT
            echo "release_decision=MISSING_SUMMARY" >> $GITHUB_OUTPUT
            exit 1
          fi
          
          echo "üìä Found readiness summary: $READINESS_FILE"
          
          # Extract readiness score and decision
          CONTENT=$(cat "$READINESS_FILE")
          
          # Parse score (handle both percentage and decimal formats)
          SCORE=$(echo "$CONTENT" | grep -iE "(readiness score|overall score)" | head -1 | grep -oE '[0-9]+(\.[0-9]+)?' | head -1 || echo "0")
          
          # Convert percentage to decimal if needed
          if (( $(echo "$SCORE > 10" | bc -l) )); then
            SCORE=$(echo "scale=1; $SCORE" | bc)
          else
            SCORE=$(echo "scale=1; $SCORE * 100" | bc)
          fi
          
          # Parse decision
          DECISION="UNKNOWN"
          if echo "$CONTENT" | grep -qi "APPROVED FOR RELEASE"; then
            DECISION="APPROVED FOR RELEASE"
          elif echo "$CONTENT" | grep -qi "CONDITIONAL"; then
            DECISION="CONDITIONAL"
          elif echo "$CONTENT" | grep -qi "NOT READY\|BLOCKED"; then
            DECISION="BLOCKED"
          fi
          
          echo "üìä Readiness Score: $SCORE%"
          echo "üéØ Release Decision: $DECISION"
          
          # Determine if we should release
          SHOULD_RELEASE="false"
          if [[ "$DECISION" == "APPROVED FOR RELEASE" ]]; then
            if (( $(echo "$SCORE >= $MIN_READINESS_SCORE" | bc -l) )); then
              SHOULD_RELEASE="true"
            else
              echo "‚ö†Ô∏è Score $SCORE% below minimum $MIN_READINESS_SCORE%"
            fi
          fi
          
          # Override for manual dispatch
          if [[ "${{ github.event_name }}" == "workflow_dispatch" && "${{ github.event.inputs.force_release }}" == "true" ]]; then
            echo "üö® Force release enabled - bypassing score check"
            SHOULD_RELEASE="true"
          fi
          
          echo "should_release=$SHOULD_RELEASE" >> $GITHUB_OUTPUT
          echo "readiness_score=$SCORE" >> $GITHUB_OUTPUT
          echo "release_decision=$DECISION" >> $GITHUB_OUTPUT
          
          if [[ "$SHOULD_RELEASE" != "true" ]]; then
            echo "‚ùå Release criteria not met"
            exit 1
          fi
          
          echo "‚úÖ Release readiness validated"
      
      - name: üè∑Ô∏è Generate Release Tag
        id: generate_tag
        run: |
          # Generate semantic version tag
          DATE=$(date +%Y%m%d)
          TIME=$(date +%H%M%S)
          
          if [[ "${{ github.event_name }}" == "workflow_dispatch" ]]; then
            RELEASE_TYPE="${{ github.event.inputs.release_type }}"
          else
            RELEASE_TYPE="patch"
          fi
          
          # Get latest tag for version bumping
          LATEST_TAG=$(git tag -l "v*" | sort -V | tail -1)
          if [[ -z "$LATEST_TAG" ]]; then
            LATEST_TAG="v0.0.0"
          fi
          
          # Parse version components
          VERSION=$(echo "$LATEST_TAG" | sed 's/^v//')
          IFS='.' read -ra VERSION_PARTS <<< "$VERSION"
          MAJOR=${VERSION_PARTS[0]:-0}
          MINOR=${VERSION_PARTS[1]:-0}
          PATCH=${VERSION_PARTS[2]:-0}
          
          # Bump version based on type
          case "$RELEASE_TYPE" in
            major)
              MAJOR=$((MAJOR + 1))
              MINOR=0
              PATCH=0
              ;;
            minor)
              MINOR=$((MINOR + 1))
              PATCH=0
              ;;
            patch)
              PATCH=$((PATCH + 1))
              ;;
            hotfix)
              PATCH=$((PATCH + 1))
              ;;
          esac
          
          NEW_VERSION="v${MAJOR}.${MINOR}.${PATCH}"
          RELEASE_TAG="${NEW_VERSION}-prod-${DATE}"
          
          echo "üè∑Ô∏è Generated release tag: $RELEASE_TAG"
          echo "release_tag=$RELEASE_TAG" >> $GITHUB_OUTPUT

  automated-production-release:
    name: üöÄ Execute Automated Release
    runs-on: ubuntu-latest
    needs: validate-release-readiness
    if: needs.validate-release-readiness.outputs.should_release == 'true'
    
    environment: 
      name: production
      url: https://github.com/${{ github.repository }}/releases/tag/${{ needs.validate-release-readiness.outputs.release_tag }}
    
    steps:
      - name: üì• Checkout Repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          token: ${{ secrets.GITHUB_TOKEN }}
      
      - name: üêç Setup Python
        uses: actions/setup-python@v4
        with:
          python-version: '3.12'
      
      - name: üì¶ Install Dependencies
        run: |
          python -m pip install --upgrade pip
          pip install -r requirements.txt
      
      - name: üîß Configure Git
        run: |
          git config --global user.name "github-actions[bot]"
          git config --global user.email "github-actions[bot]@users.noreply.github.com"
      
      - name: üîë Setup GitHub CLI
        run: |
          # GitHub CLI is pre-installed on GitHub Actions runners
          gh auth status
          gh config set git_protocol https
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      
      - name: üìã Pre-Release Validation
        run: |
          echo "üîç Running pre-release validation..."
          
          # Check required files exist
          required_files=(
            "scripts/auto_release.sh"
            "scripts/release_production.sh" 
            "scripts/consolidated_release_report.py"
            "scripts/render_release_notes.py"
            "docs/release_notes_template.md"
          )
          
          for file in "${required_files[@]}"; do
            if [[ ! -f "$file" ]]; then
              echo "‚ùå Required file missing: $file"
              exit 1
            fi
          done
          
          echo "‚úÖ All required files present"
          
          # Verify readiness summary still valid
          if ! grep -qi "APPROVED FOR RELEASE" RELEASE_READINESS_SUMMARY.md 2>/dev/null && \
             ! find . -name "*readiness_summary*" -exec grep -l "APPROVED FOR RELEASE" {} \; | head -1; then
            echo "‚ùå Readiness approval not found in current state"
            exit 1
          fi
          
          echo "‚úÖ Pre-release validation passed"
      
      - name: üöÄ Execute Automated Release
        id: release
        run: |
          echo "üöÄ Starting automated release process..."
          
          RELEASE_TAG="${{ needs.validate-release-readiness.outputs.release_tag }}"
          RELEASE_NAME="Signal Service $RELEASE_TAG"
          
          echo "üìä Release Details:"
          echo "  Tag: $RELEASE_TAG"
          echo "  Name: $RELEASE_NAME"
          echo "  Readiness Score: ${{ needs.validate-release-readiness.outputs.readiness_score }}%"
          echo "  Decision: ${{ needs.validate-release-readiness.outputs.release_decision }}"
          
          # Make scripts executable
          chmod +x scripts/*.sh
          
          # Execute the automated release
          echo "üé¨ Executing: ./scripts/auto_release.sh $RELEASE_TAG \"$RELEASE_NAME\""
          ./scripts/auto_release.sh "$RELEASE_TAG" "$RELEASE_NAME"
          
          echo "‚úÖ Automated release completed successfully"
          echo "release_url=https://github.com/${{ github.repository }}/releases/tag/$RELEASE_TAG" >> $GITHUB_OUTPUT
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      
      - name: üìä Post-Release Summary
        run: |
          echo "üéâ Production Release Summary"
          echo "=========================="
          echo "Release Tag: ${{ needs.validate-release-readiness.outputs.release_tag }}"
          echo "Readiness Score: ${{ needs.validate-release-readiness.outputs.readiness_score }}%"
          echo "Release Decision: ${{ needs.validate-release-readiness.outputs.release_decision }}"
          echo "Release URL: ${{ steps.release.outputs.release_url }}"
          echo "Triggered by: ${{ github.event_name }}"
          echo "Commit SHA: ${{ github.sha }}"
          echo "=========================="
      
      - name: üìù Create Deployment Record
        run: |
          # Create deployment tracking file
          cat > deployment_record.json << EOF
          {
            "release_tag": "${{ needs.validate-release-readiness.outputs.release_tag }}",
            "release_url": "${{ steps.release.outputs.release_url }}",
            "readiness_score": ${{ needs.validate-release-readiness.outputs.readiness_score }},
            "release_decision": "${{ needs.validate-release-readiness.outputs.release_decision }}",
            "commit_sha": "${{ github.sha }}",
            "deployment_time": "$(date -u +%Y-%m-%dT%H:%M:%S.%3NZ)",
            "triggered_by": "${{ github.event_name }}",
            "workflow_run_id": "${{ github.run_id }}"
          }
          EOF
          
          echo "üìÑ Deployment record created"
          cat deployment_record.json
      
      - name: üì§ Upload Release Artifacts
        uses: actions/upload-artifact@v3
        if: always()
        with:
          name: release-artifacts-${{ needs.validate-release-readiness.outputs.release_tag }}
          path: |
            release_readiness_report_*.md
            release_notes_*.md
            deployment_record.json
            .last_release_qa_bundle
          retention-days: 90

  notify-stakeholders:
    name: üì¢ Notify Stakeholders
    runs-on: ubuntu-latest
    needs: [validate-release-readiness, automated-production-release]
    if: always() && needs.validate-release-readiness.outputs.should_release == 'true'
    
    steps:
      - name: üì¢ Success Notification
        if: needs.automated-production-release.result == 'success'
        run: |
          echo "üéâ PRODUCTION RELEASE SUCCESSFUL"
          echo "Release: ${{ needs.validate-release-readiness.outputs.release_tag }}"
          echo "Score: ${{ needs.validate-release-readiness.outputs.readiness_score }}%"
          echo "URL: https://github.com/${{ github.repository }}/releases/tag/${{ needs.validate-release-readiness.outputs.release_tag }}"
          
          # TODO: Add Slack/email notification here
          # curl -X POST -H 'Content-type: application/json' \
          #   --data '{"text":"üöÄ Signal Service released: ${{ needs.validate-release-readiness.outputs.release_tag }}"}' \
          #   ${{ secrets.SLACK_WEBHOOK_URL }}
      
      - name: üö® Failure Notification  
        if: needs.automated-production-release.result == 'failure'
        run: |
          echo "‚ùå PRODUCTION RELEASE FAILED"
          echo "Release: ${{ needs.validate-release-readiness.outputs.release_tag }}"
          echo "Check workflow logs for details"
          
          # TODO: Add failure notification here
          # curl -X POST -H 'Content-type: application/json' \
          #   --data '{"text":"üö® Signal Service release FAILED: ${{ needs.validate-release-readiness.outputs.release_tag }}"}' \
          #   ${{ secrets.SLACK_WEBHOOK_URL }}